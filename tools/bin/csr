#! /bin/bash

#	csr -- create certificate signing request

#	    usage: csr common_name [ args ]
#
#	    A CSR and private key generated using the common_name to derive file
#	    names for these artifacts as well as to compose the "subj" string in the CSR.
#	    If the "-subj <string>" argument is provided, it is passed directly to
#	    openssl.
#

common_name="$1"

#	subject string example for xANNA issued certificates
#	you will want to change this for your organization so clients will have consistent requests!
subject_string="/C=FR/ST=(none)/L=(none)/O=remulac/OU=small town/CN=${common_name}"
#subject_string=

usage() {
    echo "${0##*/}: $1" 2>&1
    echo "usage: ${0##*/} common-name [ -subj <subject string> ]" 2>&1
    exit 1
}

#	argument checking and processing
#

if [ $# -eq 0 ]
then
    usage "no arguments provided"
fi

shift

while [ $# -gt 0 ]
do
    arg="$1"

    case "$arg" in
	-subj)
	    subject_string="$2"
	    shift
	    ;;
	*)
	    usage "unrecognized argument: $arg"
	    ;;
    esac
    shift
done

if [ ! "$subject_string" ]
then
    usage "subject string must not be null"
fi

#	generate our private key to sign our CSR and TLS challanges
#
key_name="${common_name}.key.pem"
csr_name="${common_name}.csr.pem"

#	if we already have a (read-only) key, remove it so openssl can over-write it
#
/bin/rm -f "$key_name"

# create the CSR with a new, unencrypted private key
#
openssl req -nodes -newkey rsa:2048 -keyout $key_name -out $csr_name -subj "$subject_string"
chmod 400 "$key_name"

#	print the csr
#
openssl req -noout -text -in ${csr_name}
